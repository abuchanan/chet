TODO

next: server-side and load some actual data

after that: serious UI polish session



UI only
=======================

drag-to-select and the actions that use it (e.g. zoom to region, dump to fasta)

refine overview design: doesn't need to have a lot of height

keyboard shortcuts
- pan left/right
- zoom

scroll buttons, i.e. navigate left/right with mouse clicks

pick really good colors

draw actual features

integrate twitter's bootstrap css
loading inidicators

ruler

gene info popups/hover

bug: dragging selects label text

"link here" button
- or update search params in URL on position change


track configuration

pluggable track type config

onblur instead of onkeypress for ref + start + end

draggable track order

track buttons

interactive coverage track
- call out value of point nearest to cursor
- change y-max


handle empty
- if there are no features, container collapses to zero.  should be a min height
- what if no tracks are shown?

handle errors
- server timeouts
- invalid input (e.g. reference name)


dragging the offset so that elements are added/removed from the screen changes the height of the viewer.
ok, but might have effects on UX.  try to keep the viewer a reasonable height.
could also make the features jump around as the packing is changed.


groups of isoforms.  what UI is needed for this?

reference list, i.e. some way to list all available references and their sizes
- is this dependent on the size of the tracks?  if so, what controls settings the max size and how does that request the max size of a track?

ditch ref/start/end position input boxes.  with a good ruler + overview, this will be handled, and text input can happen in the same box as search. look at angular-ui's mask for this.

look at angular-ui animate

what should the "add track" UI be like?

good default location for instances


loading on every keypress, every mousemove event, is probably going to be way too much


overview panel scale is broken

there are cases where the genome is so big that the overview is useless because the visible portion will practically always be a tiny portion of the overall size.  this happens with tair 10. gbrowse handles this by providing a second "region" overview.  i always thought this took up too much real estate.  is there a better way?


feature labels



window size detection and response: think this works already. woot.

there might be a bug with svg mask/clip. for some reason it was acting strangely when applied to div.ruler, but it works fine on div.overview.  figure out if this is a bug and report it


something like coverage graph but for DGE, so it can have negative values



organization
==============

move this stuff into github issues

create some basic github documentation

create a demo site

define license



big chunks
===========

search

server-side
- prefetching, caching, and efficient server communication

create instance

create track preset

add track with no preset, configure all details



code improvement
=================
proper injection to protect against minification munging

index.html is currently running with chet.dev.  obviously this shouldn't get checked in, and i need an easy way to switch between the two while avoiding accidental check-ins



far future
===========
feedback interface.  allow users to submit feedback

users

per-user bookmarked locations. in-app bookmarking, not browser bookmarking.

instances are user specific?
- which means i need users?

sequence data

feature editor




testing
============
unit testing:  a terrible thing to have in a todo list


test odd positions
- start >= end
- end - start == 1



test out some actual data



----
UNIT/INTERFACE TESTING NOTES

when displaying a feature, the feature should not be drawn outside the bounds of the viewer.  same for end.

configure a condition where this happens:
- a feature
- a viewer

a good solution for this is CSS "overflow: hidden", which means this needs to be tested
at the browser level, with some way to perceive that it, in fact, doesn't show the overflowing feature.  sounds like comparing images.  that's tough.

this is an interesting case where the easily testable approach isn't the easiest (or best?) to implement.

-----

when features are no longer visible, their dom elements should be deleted.

in some cases, it might make sense to keep them around, if they are just outside the visible range.


----
OTHER



always namespace directives.  I spent an hour figuring out that <track> was buggy because it's an existing HTML tag
would be nice to have something that checks directives and warns about this


closing tags are important on directives



http://codereview.stackexchange.com/
http://jsfiddle.net/IgorMinar/ADukg/
http://jsfiddle.net/pkozlowski_opensource/hzxNa/1/
